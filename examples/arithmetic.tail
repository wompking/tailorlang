#TailorCalc Arithmetic Library

procedure toUnary (fab){

	#Converts a decimal string to unary, accepting only integers.

	embroider fab -p " "
	embroider fab -a " "

	type dig = ["0","1","2","3","4","5","6","7","8","9"]
	type unr = [",","|,","||,","|||,","||||,","|||||,","||||||,","|||||||,","||||||||,","|||||||||,","||||||||||,"]
	replace fab -g dig unr
	alter fab -g /, / "âˆ… "

	condition to_unary = fab - /,/ update

	while to_unary {
		alter fab -g /\|,/ ",||||||||||"
		alter fab -g / ,(\|+)/ " \1"
	}

	alter fab -g /âˆ…/ "0"
	alter fab -g /-0/ "0"
	alter fab -g /-\|/ "â€“|"
	alter fab -g /^ +/ ""
	alter fab -g / +$/ ""
}

procedure cutAssign (fab){

	#Cuts the assignment statements out of an evaluated string.

	alter fab -g /.+ ; (.+)/ "\1"
}

procedure fromUnary (fab){

	#Converts a unary string to decimal.

	alter fab -g /0/ "âˆ…"
	condition from_unary = fab - /[\|,]/ update
	alter fab -g /â€“/ " â€“ "
	while from_unary {
		embroider fab -p ","
		alter fab -g / / " ,"
		alter fab -g /\|{10}/ "|,"
		alter fab -g /,([0123456789âˆ…])/ ",0\1"
		alter fab -g /,\|([0123456789âˆ…])/ ",1\1"
		alter fab -g /,\|{2}([0123456789âˆ…])/ ",2\1"
		alter fab -g /,\|{3}([0123456789âˆ…])/ ",3\1"
		alter fab -g /,\|{4}([0123456789âˆ…])/ ",4\1"
		alter fab -g /,\|{5}([0123456789âˆ…])/ ",5\1"
		alter fab -g /,\|{6}([0123456789âˆ…])/ ",6\1"
		alter fab -g /,\|{7}([0123456789âˆ…])/ ",7\1"
		alter fab -g /,\|{8}([0123456789âˆ…])/ ",8\1"
		alter fab -g /,\|{9}([0123456789âˆ…])/ ",9\1"
		alter fab -g /,/ ""
	}
	alter fab -g / â€“ / "-"
	alter fab -g /([0123456789])âˆ…/ "\1"
	alter fab -g /âˆ…/ "0"
	alter fab -g /(0+)([0-9+])/ "\2"
}

procedure evaluate (fab){

	#Evaluates a unary string.
	#Commands that would produce non-integer values are mapped to integers with floor().

	#Takes in RPN.
	#Variable assignments should be at the very start of your calculation string, and are of the form:
	#<variable name> := ( <value> ) ; <variable name 2> := ( <value 2> ) ;...
	#Variable names consist of uppercase and lowercase Latin and Greek letters.
	#The commands can be found below â†´ .
	
	embroider previous - "FIRST"

	condition finished = fab == previous update
	condition continue = not finished update
		condition exp = fab - /\^/ update
		condition mul = fab - /\*/ update
		condition div = fab - /%/ update
		condition add = fab - /\+/ update
		condition sub = fab - /-/ update
		condition pri = fab - /(pri)|(â˜ˆâ„Œ)/ update
		condition ack = fab - /ack/ update
		condition fac = fab - /fac/ update
		condition lcm = fab - /lcm/ update
		condition gcd = fab - /gcd/ update
		condition asg = fab - /:=/ update
		condition comparisongang = fab - /(==)|(!=)|(>)|(<)|(>=)|(<=)|(eqz)|(gtz)|(ltz)|(sgn)|(abs)|(swi)/ update
		condition unaryminus = fab - /;â€“;/ update
	condition error = fab - /ERROR/ update
	while continue {

		copy fab previous

		embroider fab -p " "
		embroider fab -a " "
		if asg {
			alter fab -g / (?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©]+) := (â€“?\|*0)(.*?) (?P=V) (.*) / " \1 := \2\3 \2 \4 "
		}
		if exp {
			alter fab -g / (â€“?\|+0) â€“(\|+0) \^ / " |0 \1 \2 ^ % "
			alter fab -g / (â€“?\|+0) (\|+0) \^ / " \1 \1 \2 |0 - ^ * "
			alter fab -g / (â€“?\|+0) 0 \^ / " |0 "
			alter fab -g / 0 (â€“?\|+0) \^ / " 0 "
			alter fab -g / 0 0 \^ / " |0 "
		}
		if mul {
			alter fab -g / â€“(\|*0) â€“(\|*0) \* / " \1 \2 * "
			alter fab -g / (\|*0) â€“(\|*0) \* / " \1 \2 * ;â€“; "
			alter fab -g / â€“(\|*0) (\|*0) \* / " \1 \2 * ;â€“; "
			alter fab -g / (\|*0) (\|*0) \* / " ğ’‚\1 \2 * "
			alter fab -g / (\|*)ğ’‚\|(\|*)(0) (\|+)0 \* / " \1\4ğ’‚\2\3 \4\3 * "
			alter fab -g / (\|*)ğ’‚(0) (\|+)0 \* / " \1\2 "
			alter fab -g / (\|*0) 0 \* / " 0 "
		}
		if div {
			alter fab -g / \((.*?) (â€“\|+0) (\|+0) % (.*?)\) / " \1 0 \4 "
			alter fab -g / \((.*?) (\|+0) (â€“\|+0) % (.*?)\) / " \1 0 \4 "
			alter fab -g / \((.*?) (â€“\|+0) (â€“\|+0) % (.*?)\) / " \1 0 \4 "
			alter fab -g / â€“(\|+0) â€“(\|+0) % / " ( \1 \2 % ) "
			alter fab -g / (\|+0) â€“(\|+0) % / " ( \1 \2 % ;â€“; ) "
			alter fab -g / â€“(\|+0) (\|+0) % / " ( \1 \2 % ;â€“; ) "
			alter fab -g / (\|+0) (\|+0) % / " |0 \1 \2 - \2 % + "
			alter fab -g / 0 (\|+0) % / " 0 "
			alter fab -g / (\|+0) 0 % / " [{DIVISION BY ZERO ERROR}] "
			alter fab -g / 0 0 % / " [{DIVISION BY ZERO ERROR}] "
		}
		if add {
			alter fab -g / â€“(\|+0) â€“(\|+0) \+ / " \1 \2 + ;â€“; "
			alter fab -g / (\|+0) â€“(\|+0) \+ / " \1 \2 - "
			alter fab -g / â€“(\|+0) (\|+0) \+ / " \2 \1 - "
			alter fab -g / (\|+)0 (\|+0) \+ / " \1\2 "
			alter fab -g / 0 (\|+0) \+ / " \1 "
			alter fab -g / (\|+0) 0 \+ / " \1 "
			alter fab -g / 0 0 \+ / " 0 "
		}
		if sub {
			alter fab -g / â€“(\|+0) â€“(\|+0) - / " \1 \2 - ;â€“; "
			alter fab -g / (\|+0) â€“(\|+0) - / " \1 \2 + "
			alter fab -g / â€“(\|+0) (\|+0) - / " \1 \2 + ;â€“; "

			alter fab -g / 0 (\|+0) - / " â€“\1 "
			alter fab -g / (\|+0) 0 - / " \1 "
			alter fab -g / 0 0 - / " 0 "

			alter fab -g / (?P<V>\|*)(\|*?)0 (?P=V)(\|*?)0 - / " \2 ğ­¹ 0 \3 ğ­¹ 0 - "
		}
		
		if gcd {
			alter fab -g / â€“(\|+0) (â€“?\|+0) gcd / " \1 \2 gcd "
			alter fab -g / (â€“?\|+0) â€“(\|+0) gcd / " \1 \2 gcd "
			alter fab -g / (\|+0) 0 gcd / " \1 "
			alter fab -g / (\|+0) 0 gcd / " \1 "
			alter fab -g / (\|*0) (\|+0) gcd / " \2 \1 \2 mod gcd "
		}
		if lcm {
			alter fab -g / â€“(\|+0) (â€“?\|+0) lcm / " \1 \2 lcm "
			alter fab -g / (â€“?\|+0) â€“(\|+0) lcm / " \1 \2 lcm "
			alter fab -g / 0 0 lcm / " 0 "
			alter fab -g / (\|*0) (\|*0) lcm / " \2 \1 \1 \2 gcd % *"
		}
		alter fab -g / (â€“?\|*0) (â€“?\|*0) mod / " \1 \1 \2 % \2 * - "

		if comparisongang {
			alter fab -g / (â€“?\|*0) (â€“?\|*0) == / " \1 \2 - eqz "
			alter fab -g / (â€“?\|*0) (â€“?\|*0) != / " \1 \2 == eqz "
			alter fab -g / (â€“?\|*0) (â€“?\|*0) < / " \2 \1 - gtz "
			alter fab -g / (â€“?\|*0) (â€“?\|*0) > / " \1 \2 - gtz "
			alter fab -g / (â€“?\|*0) (â€“?\|*0) <= / " \1 \2 < \1 \2 == + gtz "
			alter fab -g / (â€“?\|*0) (â€“?\|*0) >= / " \1 \2 > \1 \2 == + gtz "

			alter fab -g / 0 eqz / " |0 "
			alter fab -g / â€“?\|+0 eqz / " 0 "

			alter fab -g / 0 gtz / " 0 "
			alter fab -g / \|+0 gtz / " |0 "
			alter fab -g / â€“\|+0 gtz / " 0 "

			alter fab -g / 0 ltz / " 0 "
			alter fab -g / \|+0 ltz / " 0 "
			alter fab -g / â€“\|+0 ltz / " |0 "

			alter fab -g / 0 sgn / " 0 "
			alter fab -g / \|+0 sgn / " |0 "
			alter fab -g / â€“\|+0 sgn / " â€“|0 "

			alter fab -g / â€“?(\|*0) abs / " \1 "

			alter fab -g / (â€“?\|*0) (â€“?\|*0) 0 swi / " \2 "
			alter fab -g / (â€“?\|*0) (â€“?\|*0) \|0 swi / " \1 "
		}

		if ack {
			alter fab -g / â€“\|+0 \|+0 ack / "[{RANGE OUT OF BOUNDS ERROR (-x y ack)}]"
			alter fab -g / \|+0 â€“\|+0 ack / "[{RANGE OUT OF BOUNDS ERROR (x -y ack)}]"
			alter fab -g / â€“\|+0 â€“\|+0 ack / "[{RANGE OUT OF BOUNDS ERROR (-x -y ack)}]"
			alter fab -g / (\|+0) (\|+0) ack / " \1 |0 - \1 \2 |0 - ack ack "
			alter fab -g / (\|+0) 0 ack / " \1 |0 - |0 ack "
			alter fab -g / 0 (\|+0) ack / " \1 |0 + "
		}

		if pri {
			alter fab -g / â€“(\|*0) pri / " \1 pri "
			alter fab -g / \|{0,1}0 pri / " 0 "
			alter fab -g / \|{2}0 pri / " |0 "
			alter fab -g / (\|{3,}0) pri / " \1 \1 |0 - â˜ˆâ„Œ eqz "
			alter fab -g / (\|*0) (\|{3,}0) â˜ˆâ„Œ / " \1 \2 mod eqz \1 \2 |0 - â˜ˆâ„Œ + "
			alter fab -g / (\|*0) (\|{2}0) â˜ˆâ„Œ / " \1 ||0 mod eqz "
		}

		if fac {
			alter fab -g / â€“\|+0 fac / " [{RANGE OUT OF BOUNDS ERROR (-x fac)}] "
			alter fab -g / \|{0,1}0 fac / " |0 "
			alter fab -g / (\|{2,}0) fac / " \1 |0 - fac \1 * "
		}

		alter fab -g / (\|*0) (\|*0) chs / " \1 fac \2 fac \1 \2 - fac * % "

		if unaryminus {
			alter fab -g /(\|+0) ;â€“;/ "â€“\1"
			alter fab -g /â€“(\|+0) ;â€“;/ "\1"
			alter fab -g /0 ;â€“;/ "0"
		}
		alter fab -g / ğ­¹ / ""
		alter fab -g /\( (\|+0) \)/ " \1 "
		alter fab -g / +/ " "

		if error {
			alter fab -g /([^\[\]\{\}])*(\[{.+}\])([^\[\]\{\}])*/ "\2"
			dye fab 1
			copy fab garment
			sell
			stop
		}
		alter fab -g /^ +/ ""
		alter fab -g / +$/ ""

	}

}
