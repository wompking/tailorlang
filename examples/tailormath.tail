#Tailor Mathematics Library

procedure toUnary (fab){

	#Converts a decimal string to unary, and makes aliases, accepting only integers.

	embroider fab -p " "
	embroider fab -a " "

	type dig = ["0","1","2","3","4","5","6","7","8","9"]
	type unr = [",","|,","||,","|||,","||||,","|||||,","||||||,","|||||||,","||||||||,","|||||||||,","||||||||||,"]
	replace fab -g dig unr
	alter fab -g /, / "âˆ… "

	condition to_unary = fab - /,/ update

	while to_unary {
		alter fab -g /\|,/ ",||||||||||"
		alter fab -g / ,(\|+)/ " \1"
	}

	alter fab -g /âˆ…/ "0"
	alter fab -g /-0/ "0"
	alter fab -g /-\|/ "â€“|"
	alter fab -g /^ +/ ""
	alter fab -g / +$/ ""

	alter fab -g / (\?|switch) / " swi "
	alter fab -g / (ackermann) / " ack "
	alter fab -g / (prime) / " pri "
	alter fab -g / (divisors) / " div "
	alter fab -g / (sign) / " sgn "
	alter fab -g / (modulus) / " mod "
	alter fab -g / (choose) / " chs "
	alter fab -g / (factorial) / " fac "
	alter fab -g / (âˆ‘) / " sum "
	alter fab -g / (product|âˆ) / " prod "
	alter fab -g / (reduce|ğš¸) / " red "
	
}

procedure toUnaryHex (fab){

	#Converts a hexadecimal string to unary, accepting only integers.

	embroider fab -p " "
	embroider fab -a " "

	type dig = ["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"]
	type unr = [",","|,","||,","|||,","||||,","|||||,","||||||,","|||||||,","||||||||,","|||||||||,","||||||||||,","|||||||||||,","||||||||||||,","|||||||||||||,","||||||||||||||,","|||||||||||||||,"]
	replace fab -g dig unr
	alter fab -g /, / "âˆ… "

	condition to_unary = fab - /,/ update

	while to_unary {
		alter fab -g /\|,/ ",|||||||||||||||"
		alter fab -g / ,(\|+)/ " \1"
	}

	alter fab -g /âˆ…/ "0"
	alter fab -g /-0/ "0"
	alter fab -g /-\|/ "â€“|"
	alter fab -g /^ +/ ""
	alter fab -g / +$/ ""
}

procedure cutAssign (fab){

	#Cuts the assignment statements out of an evaluated string.

	alter fab -g / ; ([a-zA-zÎ±-Ï‰Î‘-Î©_]+ := ((â€“?\d+)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{.+})))/ " ; \1 ; "
	alter fab -g /.* ; (.+)/ "\1"
}

procedure getAssign (fab){

	#Gets assignment statements from an evaluated string.

	alter fab -g / ; ([a-zA-zÎ±-Ï‰Î‘-Î©_]+ := ((â€“?\d+)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{.+})))/ " ; \1 ; "
	alter fab -g /(.+) ; .*/ "\1"
}

procedure formatAssign (fab){

	#Formats assignment statements nicely.

	alter fab -g /^ +/ ""
	alter fab -g / +$/ " "
	alter fab -g /( ; )+/ " ; "
	alter fab -g /(; )+/ "; "
	alter fab -g /(?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©_]+) := ((â€“?\d+)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{.+}))(.*?) (?P=V) := ((â€“?\d+)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{.+}))/ " \1 := \4 \3 "
	alter fab -g /(?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©_]+ := ((â€“?\d+)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{.+})) ; )(.*?)(?P=V)/ "\1\2"
	alter fab -g / ; [^a-zA-zÎ±-Ï‰Î‘-Î©_]+ := ((â€“?\d+)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{.+})) ; / " ; "
	alter fab -g /^ +/ ""
	alter fab -g / +$/ " "
	alter fab -g /( ; )+/ " ; "
	alter fab -g /(; )+/ "; "

}


procedure fromUnary (fab){

	#Converts a unary string to decimal.

	alter fab -g /0/ "âˆ…"
	condition from_unary = fab - /[\|,]/ update
	alter fab -g /â€“/ " â€“ "
	while from_unary {
		embroider fab -p ","
		alter fab -g / / " ,"
		alter fab -g /\|{10}/ "|,"
		alter fab -g /,([0123456789âˆ…])/ ",0\1"
		alter fab -g /,\|([0123456789âˆ…])/ ",1\1"
		alter fab -g /,\|{2}([0123456789âˆ…])/ ",2\1"
		alter fab -g /,\|{3}([0123456789âˆ…])/ ",3\1"
		alter fab -g /,\|{4}([0123456789âˆ…])/ ",4\1"
		alter fab -g /,\|{5}([0123456789âˆ…])/ ",5\1"
		alter fab -g /,\|{6}([0123456789âˆ…])/ ",6\1"
		alter fab -g /,\|{7}([0123456789âˆ…])/ ",7\1"
		alter fab -g /,\|{8}([0123456789âˆ…])/ ",8\1"
		alter fab -g /,\|{9}([0123456789âˆ…])/ ",9\1"
		alter fab -g /,/ ""
	}
	alter fab -g / â€“ / "-"
	alter fab -g /([0123456789])âˆ…/ "\1"
	alter fab -g /âˆ…/ "0"
	alter fab -g / (0+)([0-9]+)/ " \2"
}

procedure fromUnaryHex (fab){

	#Converts a unary string to hexadecimal.

	alter fab -g /0/ "âˆ…"
	condition from_unary = fab - /[\|,]/ update
	alter fab -g /â€“/ " â€“ "
	while from_unary {
		embroider fab -p ","
		alter fab -g / / " ,"
		alter fab -g /\|{16}/ "|,"
		alter fab -g /,([0123456789abcdefâˆ…])/ ",0\1"
		alter fab -g /,\|([0123456789abcdefâˆ…])/ ",1\1"
		alter fab -g /,\|{2}([0123456789abcdefâˆ…])/ ",2\1"
		alter fab -g /,\|{3}([0123456789abcdefâˆ…])/ ",3\1"
		alter fab -g /,\|{4}([0123456789abcdefâˆ…])/ ",4\1"
		alter fab -g /,\|{5}([0123456789abcdefâˆ…])/ ",5\1"
		alter fab -g /,\|{6}([0123456789abcdefâˆ…])/ ",6\1"
		alter fab -g /,\|{7}([0123456789abcdefâˆ…])/ ",7\1"
		alter fab -g /,\|{8}([0123456789abcdefâˆ…])/ ",8\1"
		alter fab -g /,\|{9}([0123456789abcdefâˆ…])/ ",9\1"
		alter fab -g /,\|{10}([0123456789abcdefâˆ…])/ ",a\1"
		alter fab -g /,\|{11}([0123456789abcdefâˆ…])/ ",b\1"
		alter fab -g /,\|{12}([0123456789abcdefâˆ…])/ ",c\1"
		alter fab -g /,\|{13}([0123456789abcdefâˆ…])/ ",d\1"
		alter fab -g /,\|{14}([0123456789abcdefâˆ…])/ ",e\1"
		alter fab -g /,\|{15}([0123456789abcdefâˆ…])/ ",f\1"
		alter fab -g /,/ ""
	}
	alter fab -g / â€“ / "-"
	alter fab -g /([0123456789abcdef])âˆ…/ "\1"
	alter fab -g /âˆ…/ "0"
	alter fab -g / (0+)([0-9a-f]+)/ " \2"
}

procedure evaluate (fab){

	#Evaluates a unary string.
	#Commands that would produce non-integer values are mapped to integers with floor().

	#Takes in RPN.
	#Variable assignments should be at the very start of your calculation string, and are of the form:
		#<variable name> := ( <value> ) ; <variable name 2> := ( <value 2> ) ;...
	#Variable assignments can be recursive, so
		#input := ( 1 ) ; input := ( 1 + )
	#works.
	#Variable names consist of uppercase and lowercase Latin and Greek letters, and underscores.
	#Functions have the syntax:
		<paramâ‰¥>{expr}
	#and only take *one* parameter (same format as variable names), but they can be curried. Also, they might be able to be called recursively but i'm not sure if swi short-circuits properly.
	#The commands can be found below â†´ .
	
	embroider previous1 - "FIRST"

	condition finished1 = fab == previous1 update
	condition asg = fab - /:=/ update
	condition continue1 = not finished1 update

	while continue1 {
		copy fab previous1

		embroider fab -p " "
		embroider fab -a " "

		embroider previous2 - "FIRST"

		condition finished2 = fab == previous2 update
		condition asg = fab - /:=/ update
		condition continue2 = not finished2 update
			condition exp = fab - /\^/ update
			condition redgelikes = fab - / (sum|prod|red) / update
			condition mul = fab - /\*/ update
			condition div = fab - /[Ã·â³š]/ update
			condition add = fab - /\+/ update
			condition sub = fab - /-/ update
			condition pri = fab - / (pri)|(div)|(â˜ˆâ„Œ) / update
			condition ack = fab - / ack / update
			condition fac = fab - / fac / update
			condition lcm = fab - / lcm / update
			condition gcd = fab - / gcd / update
			condition app1 = fab - /([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}) ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})) $/ update
			condition app2 = fab - /{[a-zA-zÎ±-Ï‰Î‘-Î©_]+\$((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}))}/ update
			condition app = app1 or app2 update
			condition comparisongang = fab - / (==)|(â‰ )|(>)|(<)|(â‰¥)|(â‰¤)|(eqz)|(gtz)|(ltz)|(sgn)|(abs)|(swi) / update
			condition unaryminus = fab - /~/ update
		condition error = fab - /ERROR/ update
		#object regex
		#((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}))
		while continue2 {

			copy fab previous2

			embroider fab -p " "
			embroider fab -a " "
			while app {
				#most complicated bit

				#if we have a function, and then a value, start matching parenthases!!!!
				alter fab -g / ([a-zA-zÎ±-Ï‰Î‘-Î©_]+)=>{(((?!:=)[^;])+)} ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})) \$ / " \1=>{\2}ğ”ğ” \4 $ "

				condition matching = fab - /ğ”/ update
				while matching {
					#if we hit the start, something has gone wrong; error
					alter fab -g /^ğ”/ " Â«UNMATCHED BRACES ERRORÂ» "
					#otherwise, if we have a right brace, increase the counter
					alter fab -g /}(ğ”+)/ "\1ğ”}"
					#otherwise, if we have a left brace, decrease the counter
					alter fab -g /{ğ”(ğ”+)/ "\1{"

					#at this point, if the counter == 1 and we have hit a left brace, ( like this: " ğ”{ { } } " ) tredsform the pointer into the selection character and stop matching braces
					alter fab -g /([^ğ”])ğ”{/ "\1ğ–©{"

					#otherwise, if we have anything else, keep the counter the same
					alter fab -g /(.)(ğ”+)/ "\2\1"
				}
				#convert brace-matched functions to replacement mode
				alter fab -g / ([a-zA-zÎ±-Ï‰Î‘-Î©_]+)=>ğ–©{(((?!:=)[^;\n])+)}ğ” ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;\n])+})) \$ / " {\1$\4}{\2} "
				#if we have a string in replacement mode, replace the stuff inside with the stuff outside
				alter fab -g / {(?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©_]+)\$((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}))}{(.*) (?P=V) (.*)} / " {\1$\2}{ \6 \2 \7 } "
				#if we have a string in replacement mode with *no* matching strings, return the stuff inside in parens
				alter fab -g / {(?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©_]+)\$((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}))}{ (((?! (?P=V) ).)+) } / " ( \6 ) "
			}
			if exp {
				alter fab -g / (â€“?\|+0) â€“(\|+0) \^ / " |0 \1 \2 ^ Ã· "
				alter fab -g / (â€“?\|+0) (\|+0) \^ / " \1 \1 \2 |0 - ^ * "
				alter fab -g / (â€“?\|+0) 0 \^ / " |0 "
				alter fab -g / 0 (â€“?\|+0) \^ / " 0 "
				alter fab -g / 0 0 \^ / " |0 "
			}
			if mul {
				alter fab -g / â€“(\|*0) â€“(\|*0) \* / " \1 \2 * "
				alter fab -g / (\|*0) â€“(\|*0) \* / " \1 \2 * ~ "
				alter fab -g / â€“(\|*0) (\|*0) \* / " \1 \2 * ~ "
				alter fab -g / (\|*0) (\|*0) \* / " ğ’‚\1 \2 * "
				alter fab -g / (\|*)ğ’‚\|(\|*)(0) (\|+)0 \* / " \1\4ğ’‚\2\3 \4\3 * "
				alter fab -g / (\|*)ğ’‚(0) (\|+)0 \* / " \1\2 "
				alter fab -g / (\|*0) 0 \* / " 0 "
			}
			if div {
				alter fab -g / 0 â€“?(\|+0) Ã· / " 0 "
				alter fab -g / â€“?(\|+0) 0 Ã· / " Â«DIVISION BY ZERO ERRORÂ» "
				alter fab -g / 0 0 Ã· / " Â«DIVISION BY ZERO ERRORÂ» "
				alter fab -g / â€“(\|+0) â€“(\|+0) Ã· / " \1 \2 Ã· "
				alter fab -g / (\|+0) â€“(\|+0) Ã· / " \1 \2 Ã· ~ "
				alter fab -g / â€“(\|+0) (\|+0) Ã· / " \1 \2 Ã· ~ "
				alter fab -g / (\|+0) (\|+0) Ã· / " \2 \1 Ã·ğ‹ª "

				alter fab -g / (\|+0) (â³*\|*â²·*0) Ã·ğ‹ª / " \1 â³\2 Ã·ğ‹ª " 
				alter fab -g / ((?P<V>\|+)0) (â³*)(\|*)(?P=V)(â²·*)0 Ã·ğ‹ª / " \1 â³\4\5â²·0 Ã·ğ‹ª "
				alter fab -g / (\|+0) (â³{2,})(\|*)(â²·*0) Ã·ğ‹ª / " \1 \2\4 Ã·ğ‹ª "
				alter fab -g / (\|+0) (â³{2,})(?!\|+)(â²·â²·*0) Ã·ğ‹ª / " \3 â³š "
				alter fab -g / (\|*)â²·(â²·+)0 â³š / " |\1\2 Õ– 0 â³š "
				alter fab -g / (\|*)â²·0 â³š / " |\1 Õ– 0 "
			}
			if add {
				alter fab -g / â€“(\|+0) â€“(\|+0) \+ / " \1 \2 + ~ "
				alter fab -g / (\|+0) â€“(\|+0) \+ / " \1 \2 - "
				alter fab -g / â€“(\|+0) (\|+0) \+ / " \2 \1 - "
				alter fab -g / (\|+)0 (\|+0) \+ / " \1\2 "
				alter fab -g / 0 (\|+0) \+ / " \1 "
				alter fab -g / (\|+0) 0 \+ / " \1 "
				alter fab -g / 0 0 \+ / " 0 "
				alter fab -g / \( (â€“?\|+0) \+ \) / " \1 "
			}
			if sub {
				alter fab -g / â€“(\|+0) â€“(\|+0) - / " \1 \2 - ~ "
				alter fab -g / (\|+0) â€“(\|+0) - / " \1 \2 + "
				alter fab -g / â€“(\|+0) (\|+0) - / " \1 \2 + ~ "

				alter fab -g / 0 (\|+0) - / " â€“\1 "
				alter fab -g / (\|+0) 0 - / " \1 "
				alter fab -g / 0 0 - / " 0 "

				alter fab -g / (?P<V>\|*)(\|*?)0 (?P=V)(\|*?)0 - / " \2 Õ– 0 \3 Õ– 0 - "
			}
			
			if gcd {
				alter fab -g / â€“(\|+0) (â€“?\|+0) gcd / " \1 \2 gcd "
				alter fab -g / (â€“?\|+0) â€“(\|+0) gcd / " \1 \2 gcd "
				alter fab -g / (\|+0) 0 gcd / " \1 "
				alter fab -g / (\|+0) 0 gcd / " \1 "
				alter fab -g / (\|*0) (\|+0) gcd / " \2 \1 \2 mod gcd "
			}
			if lcm {
				alter fab -g / â€“(\|+0) (â€“?\|+0) lcm / " \1 \2 lcm "
				alter fab -g / (â€“?\|+0) â€“(\|+0) lcm / " \1 \2 lcm "
				alter fab -g / 0 0 lcm / " 0 "
				alter fab -g / (\|*0) (\|*0) lcm / " \2 \1 \1 \2 gcd Ã· *"
			}
			alter fab -g / (â€“?\|*0) (â€“?\|*0) mod / " \1 \1 \2 Ã· \2 * - "

			if comparisongang {
				alter fab -g / (â€“?\|*0) (â€“?\|*0) == / " \1 \2 - eqz "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) â‰  / " \1 \2 == eqz "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) < / " \2 \1 - gtz "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) > / " \1 \2 - gtz "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) â‰¤ / " \1 \2 < \1 \2 == + gtz "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) â‰¥ / " \1 \2 > \1 \2 == + gtz "

				alter fab -g / 0 eqz / " |0 "
				alter fab -g / â€“?\|+0 eqz / " 0 "

				alter fab -g / 0 gtz / " 0 "
				alter fab -g / \|+0 gtz / " |0 "
				alter fab -g / â€“\|+0 gtz / " 0 "

				alter fab -g / 0 ltz / " 0 "
				alter fab -g / \|+0 ltz / " 0 "
				alter fab -g / â€“\|+0 ltz / " |0 "

				alter fab -g / 0 sgn / " 0 "
				alter fab -g / \|+0 sgn / " |0 "
				alter fab -g / â€“\|+0 sgn / " â€“|0 "

				alter fab -g / â€“?(\|*0) abs / " \1 "

				condition swi = fab - /ğ–©„/ update
				#better group matching to make recursive functions possible
				alter fab -g / ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+) (\(.+\)) (â€“?\|*0) swi / " \1 \5ğ–©„ğ–© \6 swi "
				alter fab -g / (\(.+\)) ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+) (â€“?\|*0) swi / " \1ğ–©„ğ–© \2 \6 swi "
				alter fab -g / (\(.+\)) (\(.+\)) (â€“?\|*0) swi / " \1ğ–©„ğ–© \2ğ–©„ğ–© \3 swi "
				while swi {
					alter fab -g /^ğ–©„/ " Â«UNMATCHED PARENTHASES ERRORÂ» "
					alter fab -g /\)(ğ–©„+)/ "\1ğ–©„)"
					alter fab -g /\(ğ–©„(ğ–©„+)/ "\1("

					alter fab -g /([^ğ–©„])ğ–©„\(/ "\1ğ–©‚("

					alter fab -g /(.)(ğ–©„+)/ "\2\1"
				}
				alter fab -g / ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+|ğ–©‚.+ğ–©) ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+|ğ–©‚.+ğ–©) â€“\|+0 swi / " \5 "
				alter fab -g / ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+|ğ–©‚.+ğ–©) ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+|ğ–©‚.+ğ–©) 0 swi / " \5 "
				alter fab -g / ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+|ğ–©‚.+ğ–©) ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})|[a-zA-zÎ±-Ï‰Î‘-Î©_]+|ğ–©‚.+ğ–©) \|+0 swi / " \1 "
				alter fab -g /[ğ–©‚ğ–©„ğ–©]/ " "
			}

			if ack {
				alter fab -g / â€“\|+0 \|+0 ack / "Â«REDGE OUT OF BOUNDS ERROR (-x y ack)Â»"
				alter fab -g / \|+0 â€“\|+0 ack / "Â«REDGE OUT OF BOUNDS ERROR (x -y ack)Â»"
				alter fab -g / â€“\|+0 â€“\|+0 ack / "Â«REDGE OUT OF BOUNDS ERROR (-x -y ack)Â»"
				alter fab -g / (\|+0) (\|+0) ack / " \1 |0 - \1 \2 |0 - ack ack "
				alter fab -g / (\|+0) 0 ack / " \1 |0 - |0 ack "
				alter fab -g / 0 (\|+0) ack / " \1 |0 + "
			}

			if pri {
				embroider previouspri "FIRST"
				condition finishedpri = fab == previouspri update
				condition continuepri = not finishedpri update
				while continuepri {
					copy fab previouspri
					alter fab -g / (((?P<V>\|{2,})(?P=V)+)|\|)0 pri / " 0 pri "
				}
				alter fab -g / pri / " eqz eqz "

				alter fab -g / â€“(\|*0) div / " \1 div "
				alter fab -g / \|{0,3}0 div / " 0 "
				alter fab -g / (\|{4,}0) div / " \1 \1 |0 - â˜ˆâ„Œ "

				alter fab -g / (\|*0) (\|{3,}0) â˜ˆâ„Œ / " \1 \2 mod eqz \1 \2 |0 - â˜ˆâ„Œ + "
				alter fab -g / (\|*0) (\|{2}0) â˜ˆâ„Œ / " \1 ||0 mod eqz "
			}

			if fac {
				alter fab -g / â€“\|+0 fac / " Â«REDGE OUT OF BOUNDS ERROR (-x fac)Â» "
				alter fab -g / \|{0,1}0 fac / " |0 "
				alter fab -g / (\|{2,}0) fac / " \1 |0 - fac \1 * "
			}
			if redgelikes {
				alter fab -g / (â€“?\|*0) (â€“?\|*0) ([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}) sum / " ( 0 ) ( \1 1 + \2 \3 sum ) \1 \2 == swi \3 \1 $ + "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) ([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}) prod / " ( 0 ) ( \1 1 + \2 \3 prod ) \1 \2 == swi \3 \1 $ * "
				alter fab -g / (â€“?\|*0) (â€“?\|*0) ([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}) (â€“?\|*0) ([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}) red / " ( \5 ) ( \1 1 + \2 \3 \5 \6 red ) \1 \2 == swi \3 \1 $ \6 $ $ "
			}

			alter fab -g / (\|*0) (\|*0) chs / " \1 fac \2 fac \1 \2 - fac * Ã· "

			if unaryminus {
				alter fab -g /(\|+0) ~/ "â€“\1"
				alter fab -g /â€“(\|+0) ~/ "\1"
				alter fab -g /0 ~/ "0"
			}
			alter fab -g / Õ– / ""
			#unwrap parenthases
			alter fab -g /\( ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})) \)/ " \1 "
			#add spaces to parenthases to compensate for things
			alter fab -g /\(/ "( "
			alter fab -g /{/ "{ "
			alter fab -g /\)/ " )"
			alter fab -g /}/ " }"
			alter fab -g / +/ " "

			if error {
				alter fab -g /([^Â«Â»])*(Â«.+Â»)([^Â«Â»])*/ "\2"
				dye fab 1
				copy fab garment
				sell
				stop
			}
			alter fab -g /^ +/ ""
			alter fab -g / +$/ ""
		}
		embroider fab -p " "
		embroider fab -a " "
		if asg {
			# delete multiple assigments
			alter fab -g / (?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©_]+) := ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})) (.*?) (?P=V) := ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+})) (.*)/ " \1 := \4 \3 \5"
			# replace reference values with evaluated values
			alter fab -g / (?P<V>[a-zA-zÎ±-Ï‰Î‘-Î©_]+) := ((â€“?\|*0)|([a-zA-zÎ±-Ï‰Î‘-Î©_]+=>{((?!:=)[^;])+}))(.*?) (?P=V) (?!:=)(.*)/ " \1 := \2\6 \2 \7 "
		}
		alter fab -g /^ +/ ""
		alter fab -g / +$/ ""
	}

}

procedure quickeval (fab){
	do toUnary (fab)
	do evaluate (fab)
	do fromUnary (fab)
}

procedure quickevalHex (fab){
	do toUnaryHex (fab)
	do evaluate (fab)
	do fromUnaryHex (fab)
}

#embroider test " scale := a=>{ a ||0 * |0 + } ; scale |||0 $ scale ||||0 $ scale |||||0 $ "
#embroider test " a=>{ b=>{ a b * } } ||0 $ |||0 $ "
#embroider test " alzero := a=>{ 0 ( alzero a |0 - $ ) a 0 == swi } ; alzero |||0 $ "
#embroider test " fact := x=>{ |0 ( fact x |0 - $ x * ) x 0 â‰¤ swi } ; fact ||||0 $ "
#embroider test " 0 pri |0 pri ||0 pri |||0 pri ||||0 pri |||||0 pri ||||||0 pri |||||||0 pri ||||||||0 pri |||||||||0 pri ||||||||||0 pri "
#embroider test " ||||||||0 |||0 Ã· "

#do evaluate (test)
#copy test garment
#sell